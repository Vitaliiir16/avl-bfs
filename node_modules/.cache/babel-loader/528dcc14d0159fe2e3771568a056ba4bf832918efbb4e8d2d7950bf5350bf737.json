{"ast":null,"code":"// src/components/Graph/algorithms/depthFirstSearch.js\n\nexport const depthFirstSearch = async (nodes, edges, startId, endId, updateNodeState, setStepHistory, delay = 1000, isPausedRef // Додаємо параметр для рефа паузи\n) => {\n  const visited = new Set();\n  const stack = [startId];\n  while (stack.length > 0) {\n    // Перевіряємо, чи не встановлена пауза\n    if (isPausedRef.current) {\n      // Якщо пауза встановлена, чекаємо поки її не знімуть\n      await new Promise(resolve => {\n        const interval = setInterval(() => {\n          if (!isPausedRef.current) {\n            clearInterval(interval);\n            resolve();\n          }\n        }, 100); // Перевіряємо кожні 100 мс\n      });\n    }\n    const current = stack.pop();\n    if (!visited.has(current)) {\n      visited.add(current);\n\n      // Оновлюємо стан поточної вершини на \"processing\"\n      updateNodeState(current, 'processing');\n\n      // Затримка для анімації\n      await new Promise(resolve => setTimeout(resolve, delay));\n      if (current === endId) {\n        // Якщо знайшли цільову вершину, оновлюємо її стан на \"target\"\n        updateNodeState(current, 'target');\n        alert(`Знайдено кінцеву вершину V${endId}`);\n        return;\n      }\n\n      // Отримуємо сусідів\n      const neighbors = edges.filter(edge => edge.from === current).map(edge => edge.to).filter(neighbor => !visited.has(neighbor));\n\n      // Додаємо сусідів у стек\n      neighbors.forEach(neighbor => stack.push(neighbor));\n\n      // Оновлюємо стан поточної вершини на \"visited\"\n      updateNodeState(current, 'visited');\n\n      // Зберігаємо крок у історію\n      setStepHistory(prevHistory => [...prevHistory, current]);\n\n      // Затримка для анімації\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  alert('Цільова вершина не знайдена');\n};","map":{"version":3,"names":["depthFirstSearch","nodes","edges","startId","endId","updateNodeState","setStepHistory","delay","isPausedRef","visited","Set","stack","length","current","Promise","resolve","interval","setInterval","clearInterval","pop","has","add","setTimeout","alert","neighbors","filter","edge","from","map","to","neighbor","forEach","push","prevHistory"],"sources":["D:/kr/src/components/Graph/algorithms/depthFirstSearch.js"],"sourcesContent":["// src/components/Graph/algorithms/depthFirstSearch.js\r\n\r\nexport const depthFirstSearch = async (\r\n  nodes,\r\n  edges,\r\n  startId,\r\n  endId,\r\n  updateNodeState,\r\n  setStepHistory,\r\n  delay = 1000,\r\n  isPausedRef // Додаємо параметр для рефа паузи\r\n) => {\r\n  const visited = new Set();\r\n  const stack = [startId];\r\n\r\n  while (stack.length > 0) {\r\n    // Перевіряємо, чи не встановлена пауза\r\n    if (isPausedRef.current) {\r\n      // Якщо пауза встановлена, чекаємо поки її не знімуть\r\n      await new Promise((resolve) => {\r\n        const interval = setInterval(() => {\r\n          if (!isPausedRef.current) {\r\n            clearInterval(interval);\r\n            resolve();\r\n          }\r\n        }, 100); // Перевіряємо кожні 100 мс\r\n      });\r\n    }\r\n\r\n    const current = stack.pop();\r\n\r\n    if (!visited.has(current)) {\r\n      visited.add(current);\r\n\r\n      // Оновлюємо стан поточної вершини на \"processing\"\r\n      updateNodeState(current, 'processing');\r\n\r\n      // Затримка для анімації\r\n      await new Promise((resolve) => setTimeout(resolve, delay));\r\n\r\n      if (current === endId) {\r\n        // Якщо знайшли цільову вершину, оновлюємо її стан на \"target\"\r\n        updateNodeState(current, 'target');\r\n        alert(`Знайдено кінцеву вершину V${endId}`);\r\n        return;\r\n      }\r\n\r\n      // Отримуємо сусідів\r\n      const neighbors = edges\r\n        .filter((edge) => edge.from === current)\r\n        .map((edge) => edge.to)\r\n        .filter((neighbor) => !visited.has(neighbor));\r\n\r\n      // Додаємо сусідів у стек\r\n      neighbors.forEach((neighbor) => stack.push(neighbor));\r\n\r\n      // Оновлюємо стан поточної вершини на \"visited\"\r\n      updateNodeState(current, 'visited');\r\n\r\n      // Зберігаємо крок у історію\r\n      setStepHistory((prevHistory) => [...prevHistory, current]);\r\n\r\n      // Затримка для анімації\r\n      await new Promise((resolve) => setTimeout(resolve, delay));\r\n    }\r\n  }\r\n\r\n  alert('Цільова вершина не знайдена');\r\n};\r\n"],"mappings":"AAAA;;AAEA,OAAO,MAAMA,gBAAgB,GAAG,MAAAA,CAC9BC,KAAK,EACLC,KAAK,EACLC,OAAO,EACPC,KAAK,EACLC,eAAe,EACfC,cAAc,EACdC,KAAK,GAAG,IAAI,EACZC,WAAW,CAAC;AAAA,KACT;EACH,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,MAAMC,KAAK,GAAG,CAACR,OAAO,CAAC;EAEvB,OAAOQ,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IACvB;IACA,IAAIJ,WAAW,CAACK,OAAO,EAAE;MACvB;MACA,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAAK;QAC7B,MAAMC,QAAQ,GAAGC,WAAW,CAAC,MAAM;UACjC,IAAI,CAACT,WAAW,CAACK,OAAO,EAAE;YACxBK,aAAa,CAACF,QAAQ,CAAC;YACvBD,OAAO,CAAC,CAAC;UACX;QACF,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MACX,CAAC,CAAC;IACJ;IAEA,MAAMF,OAAO,GAAGF,KAAK,CAACQ,GAAG,CAAC,CAAC;IAE3B,IAAI,CAACV,OAAO,CAACW,GAAG,CAACP,OAAO,CAAC,EAAE;MACzBJ,OAAO,CAACY,GAAG,CAACR,OAAO,CAAC;;MAEpB;MACAR,eAAe,CAACQ,OAAO,EAAE,YAAY,CAAC;;MAEtC;MACA,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAAKO,UAAU,CAACP,OAAO,EAAER,KAAK,CAAC,CAAC;MAE1D,IAAIM,OAAO,KAAKT,KAAK,EAAE;QACrB;QACAC,eAAe,CAACQ,OAAO,EAAE,QAAQ,CAAC;QAClCU,KAAK,CAAC,6BAA6BnB,KAAK,EAAE,CAAC;QAC3C;MACF;;MAEA;MACA,MAAMoB,SAAS,GAAGtB,KAAK,CACpBuB,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACC,IAAI,KAAKd,OAAO,CAAC,CACvCe,GAAG,CAAEF,IAAI,IAAKA,IAAI,CAACG,EAAE,CAAC,CACtBJ,MAAM,CAAEK,QAAQ,IAAK,CAACrB,OAAO,CAACW,GAAG,CAACU,QAAQ,CAAC,CAAC;;MAE/C;MACAN,SAAS,CAACO,OAAO,CAAED,QAAQ,IAAKnB,KAAK,CAACqB,IAAI,CAACF,QAAQ,CAAC,CAAC;;MAErD;MACAzB,eAAe,CAACQ,OAAO,EAAE,SAAS,CAAC;;MAEnC;MACAP,cAAc,CAAE2B,WAAW,IAAK,CAAC,GAAGA,WAAW,EAAEpB,OAAO,CAAC,CAAC;;MAE1D;MACA,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAAKO,UAAU,CAACP,OAAO,EAAER,KAAK,CAAC,CAAC;IAC5D;EACF;EAEAgB,KAAK,CAAC,6BAA6B,CAAC;AACtC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}