{"ast":null,"code":"export const initializeDFS = (nodes, endNodeId) => {\n  const updatedNodes = nodes.map(n => ({\n    ...n,\n    state: 'unvisited'\n  }));\n  return {\n    nodes: updatedNodes,\n    stepHistory: [],\n    currentNode: null,\n    targetNode: endNodeId,\n    stack: []\n  };\n};\nexport const startDFS = (startId, endId, setIsRunning, setIsPaused, setTargetNode, setStack, setNodes) => {\n  setIsRunning(true);\n  setIsPaused(false);\n  setTargetNode(endId);\n  setNodes(p => p.map(n => ({\n    ...n,\n    state: 'unvisited'\n  })));\n  setStack([startId]);\n};\nfunction nextNode(stack, nodesRef, setStack, isPausedRef, setIsRunning) {\n  while (true) {\n    if (stack.length === 0) {\n      alert('Цільова вершина не знайдена');\n      setIsRunning(false);\n      return null;\n    }\n    if (isPausedRef.current) return null;\n    const c = stack[stack.length - 1];\n    const cNode = nodesRef.current.find(n => n.id === c);\n    if (!cNode || cNode.state !== 'unvisited') {\n      setStack(prev => prev.slice(0, -1));\n      continue;\n    }\n    return c;\n  }\n}\nexport const performDFSStep = async ({\n  nodesRef,\n  edges,\n  stack,\n  setStack,\n  updateNodeState,\n  setStepHistory,\n  delay,\n  targetNode: finalNode,\n  isPausedRef,\n  setIsRunning\n}) => {\n  const candidate = nextNode(stack, nodesRef, setStack, isPausedRef, setIsRunning);\n  if (candidate === null) return;\n  updateNodeState(candidate, 'processing');\n  setStepHistory(h => [...h, candidate]);\n  await new Promise(r => setTimeout(r, delay));\n  if (candidate === finalNode) {\n    updateNodeState(candidate, 'target');\n    alert('Знайдено кінцеву вершину V' + finalNode);\n    setIsRunning(false);\n    return;\n  }\n  const allNeighbors = edges.filter(e => e.from === candidate).map(e => e.to);\n  const unvisitedNeighbors = allNeighbors.filter(id => {\n    const nn = nodesRef.current.find(n => n.id === id);\n    return nn && nn.state === 'unvisited';\n  });\n  setStack(s => [...s, ...unvisitedNeighbors.reverse()]);\n  updateNodeState(candidate, 'visited');\n  await new Promise(r => setTimeout(r, delay));\n};\nexport const pauseDFS = (isRunning, setIsPaused, isPaused) => {\n  if (!isRunning) return;\n  setIsPaused(!isPaused);\n};\nexport const backDFS = (stepHistory, setStepHistory, setNodes, setStack, setCurrentNode) => {\n  if (stepHistory.length === 0) {\n    alert('Немає попередніх кроків для відкату.');\n    return;\n  }\n  const newHistory = [...stepHistory];\n  const lastNode = newHistory.pop();\n  setNodes(prev => prev.map(n => n.id === lastNode ? {\n    ...n,\n    state: 'unvisited'\n  } : n));\n  setStepHistory(newHistory);\n  setStack(prev => [...prev, lastNode]);\n  const previousNode = newHistory[newHistory.length - 1] || null;\n  setCurrentNode(previousNode);\n};","map":{"version":3,"names":["initializeDFS","nodes","endNodeId","updatedNodes","map","n","state","stepHistory","currentNode","targetNode","stack","startDFS","startId","endId","setIsRunning","setIsPaused","setTargetNode","setStack","setNodes","p","nextNode","nodesRef","isPausedRef","length","alert","current","c","cNode","find","id","prev","slice","performDFSStep","edges","updateNodeState","setStepHistory","delay","finalNode","candidate","h","Promise","r","setTimeout","allNeighbors","filter","e","from","to","unvisitedNeighbors","nn","s","reverse","pauseDFS","isRunning","isPaused","backDFS","setCurrentNode","newHistory","lastNode","pop","previousNode"],"sources":["D:/kr/src/components/Graph/algorithms/dfs.js"],"sourcesContent":["export const initializeDFS = (nodes, endNodeId) => {\r\n  const updatedNodes = nodes.map(n => ({...n, state:'unvisited'}))\r\n  return {nodes: updatedNodes, stepHistory: [], currentNode: null, targetNode: endNodeId, stack: []}\r\n}\r\n\r\nexport const startDFS = (startId, endId, setIsRunning, setIsPaused, setTargetNode, setStack, setNodes) => {\r\n  setIsRunning(true)\r\n  setIsPaused(false)\r\n  setTargetNode(endId)\r\n  setNodes(p=>p.map(n=>({...n,state:'unvisited'})))\r\n  setStack([startId])\r\n}\r\n\r\nfunction nextNode(stack, nodesRef, setStack, isPausedRef, setIsRunning) {\r\n  while (true) {\r\n    if (stack.length === 0) {\r\n      alert('Цільова вершина не знайдена')\r\n      setIsRunning(false)\r\n      return null\r\n    }\r\n    if (isPausedRef.current) return null\r\n    const c = stack[stack.length - 1]\r\n    const cNode = nodesRef.current.find(n=>n.id===c)\r\n    if (!cNode || cNode.state !== 'unvisited') {\r\n      setStack(prev=>prev.slice(0,-1))\r\n      continue\r\n    }\r\n    return c\r\n  }\r\n}\r\n\r\nexport const performDFSStep = async ({nodesRef, edges, stack, setStack, updateNodeState, setStepHistory, delay, targetNode: finalNode, isPausedRef, setIsRunning}) => {\r\n  const candidate = nextNode(stack, nodesRef, setStack, isPausedRef, setIsRunning)\r\n  if (candidate === null) return\r\n  updateNodeState(candidate, 'processing')\r\n  setStepHistory(h=>[...h,candidate])\r\n  await new Promise(r=>setTimeout(r,delay))\r\n  if (candidate === finalNode) {\r\n    updateNodeState(candidate, 'target')\r\n    alert('Знайдено кінцеву вершину V' + finalNode)\r\n    setIsRunning(false)\r\n    return\r\n  }\r\n  const allNeighbors = edges.filter(e=>e.from===candidate).map(e=>e.to)\r\n  const unvisitedNeighbors = allNeighbors.filter(id=>{\r\n    const nn = nodesRef.current.find(n=>n.id===id)\r\n    return nn && nn.state==='unvisited'\r\n  })\r\n  setStack(s => [...s,...unvisitedNeighbors.reverse()])\r\n  updateNodeState(candidate,'visited')\r\n  await new Promise(r=>setTimeout(r,delay))\r\n}\r\n\r\nexport const pauseDFS = (isRunning, setIsPaused, isPaused) => {\r\n  if (!isRunning) return\r\n  setIsPaused(!isPaused)\r\n}\r\n\r\nexport const backDFS = (stepHistory, setStepHistory, setNodes, setStack, setCurrentNode) => {\r\n  if (stepHistory.length===0) {\r\n    alert('Немає попередніх кроків для відкату.')\r\n    return\r\n  }\r\n  const newHistory = [...stepHistory]\r\n  const lastNode = newHistory.pop()\r\n  setNodes(prev=>prev.map(n=>n.id===lastNode?{...n,state:'unvisited'}:n))\r\n  setStepHistory(newHistory)\r\n  setStack(prev=>[...prev,lastNode])\r\n  const previousNode = newHistory[newHistory.length-1]||null\r\n  setCurrentNode(previousNode)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}