{"ast":null,"code":"export const initializeDFS = (nodes, endNodeId) => {\n  const updatedNodes = nodes.map(n => ({\n    ...n,\n    state: 'unvisited'\n  }));\n  return {\n    nodes: updatedNodes,\n    stepHistory: [],\n    currentNode: null,\n    targetNode: endNodeId,\n    stack: []\n  };\n};\nexport const startDFSProcess = (startId, endId, setIsRunning, setIsPaused, setTargetNode, setStack, setNodes) => {\n  setIsRunning(true);\n  setIsPaused(false);\n  setTargetNode(endId);\n  setNodes(p => p.map(n => ({\n    ...n,\n    state: 'unvisited'\n  })));\n  setStack([startId]);\n};\nexport const performDFSStep = async ({\n  nodesRef,\n  edges,\n  stack,\n  setStack,\n  updateNodeState,\n  setStepHistory,\n  delay,\n  targetNode,\n  isPausedRef,\n  setIsRunning\n}) => {\n  if (stack.length === 0) {\n    alert('Цільова вершина не знайдена');\n    setIsRunning(false);\n    return;\n  }\n  if (isPausedRef.current) return;\n  const current = stack[stack.length - 1];\n  setStack(prev => prev.slice(0, -1));\n  const currentNode = nodesRef.current.find(n => n.id === current);\n  if (!currentNode || currentNode.state !== 'unvisited') return;\n  updateNodeState(current, 'processing');\n  setStepHistory(h => [...h, current]);\n  await new Promise(r => setTimeout(r, delay));\n  if (current === targetNode) {\n    updateNodeState(current, 'target');\n    alert(`Знайдено кінцеву вершину V${targetNode}`);\n    setIsRunning(false);\n    return;\n  }\n  const neighbors = edges.filter(e => e.from === current).map(e => e.to).filter(id => {\n    const nn = nodesRef.current.find(n => n.id === id);\n    return nn && nn.state === 'unvisited';\n  });\n  setStack(s => [...s, ...neighbors.reverse()]);\n  updateNodeState(current, 'visited');\n  await new Promise(r => setTimeout(r, delay));\n};\nexport const pauseDFSProcess = (isRunning, setIsPaused, isPaused) => {\n  if (!isRunning) return;\n  setIsPaused(!isPaused);\n};\nexport const undoDFSProcess = (stepHistory, setStepHistory, setNodes, setStack, setCurrentNode) => {\n  if (stepHistory.length === 0) {\n    alert('Немає попередніх кроків для відкату.');\n    return;\n  }\n  const newHistory = [...stepHistory];\n  const lastVisitedNode = newHistory.pop();\n  setNodes(prev => prev.map(n => n.id === lastVisitedNode ? {\n    ...n,\n    state: 'unvisited'\n  } : n));\n  setStepHistory(newHistory);\n  setStack(prev => [...prev, lastVisitedNode]);\n  const previousNode = newHistory[newHistory.length - 1] || null;\n  setCurrentNode(previousNode);\n};\nexport const resetDFSProcess = (setNodes, setStepHistory, setCurrentNode, setTargetNode, setIsRunning, setIsPaused, setStack) => {\n  setNodes(prev => prev.map(n => ({\n    ...n,\n    state: 'unvisited'\n  })));\n  setStepHistory([]);\n  setCurrentNode(null);\n  setTargetNode(null);\n  setIsRunning(false);\n  setIsPaused(false);\n  setStack([]);\n};","map":{"version":3,"names":["initializeDFS","nodes","endNodeId","updatedNodes","map","n","state","stepHistory","currentNode","targetNode","stack","startDFSProcess","startId","endId","setIsRunning","setIsPaused","setTargetNode","setStack","setNodes","p","performDFSStep","nodesRef","edges","updateNodeState","setStepHistory","delay","isPausedRef","length","alert","current","prev","slice","find","id","h","Promise","r","setTimeout","neighbors","filter","e","from","to","nn","s","reverse","pauseDFSProcess","isRunning","isPaused","undoDFSProcess","setCurrentNode","newHistory","lastVisitedNode","pop","previousNode","resetDFSProcess"],"sources":["D:/kr/src/components/Graph/algorithms/dfs.js"],"sourcesContent":["export const initializeDFS = (nodes, endNodeId) => {\r\n  const updatedNodes = nodes.map(n => ({...n, state:'unvisited'}))\r\n  return {nodes:updatedNodes, stepHistory:[], currentNode:null, targetNode:endNodeId, stack:[]}\r\n}\r\n\r\nexport const startDFSProcess = (startId, endId, setIsRunning, setIsPaused, setTargetNode, setStack, setNodes) => {\r\n  setIsRunning(true)\r\n  setIsPaused(false)\r\n  setTargetNode(endId)\r\n  setNodes(p=>p.map(n=>({...n,state:'unvisited'})))\r\n  setStack([startId])\r\n}\r\n\r\nexport const performDFSStep = async ({nodesRef, edges, stack, setStack, updateNodeState, setStepHistory, delay, targetNode, isPausedRef, setIsRunning}) => {\r\n  if (stack.length === 0) {\r\n    alert('Цільова вершина не знайдена')\r\n    setIsRunning(false)\r\n    return\r\n  }\r\n  if (isPausedRef.current) return\r\n  const current = stack[stack.length - 1]\r\n  setStack(prev=>prev.slice(0,-1))\r\n  const currentNode = nodesRef.current.find(n=>n.id===current)\r\n  if (!currentNode||currentNode.state!=='unvisited') return\r\n  updateNodeState(current,'processing')\r\n  setStepHistory(h=>[...h,current])\r\n  await new Promise(r=>setTimeout(r,delay))\r\n  if (current===targetNode) {\r\n    updateNodeState(current,'target')\r\n    alert(`Знайдено кінцеву вершину V${targetNode}`)\r\n    setIsRunning(false)\r\n    return\r\n  }\r\n  const neighbors = edges.filter(e=>e.from===current).map(e=>e.to).filter(id=>{\r\n    const nn=nodesRef.current.find(n=>n.id===id)\r\n    return nn&&nn.state==='unvisited'\r\n  })\r\n  setStack(s=>[...s,...neighbors.reverse()])\r\n  updateNodeState(current,'visited')\r\n  await new Promise(r=>setTimeout(r,delay))\r\n}\r\n\r\nexport const pauseDFSProcess = (isRunning, setIsPaused, isPaused) => {\r\n  if (!isRunning) return\r\n  setIsPaused(!isPaused)\r\n}\r\n\r\nexport const undoDFSProcess = (stepHistory, setStepHistory, setNodes, setStack, setCurrentNode) => {\r\n  if (stepHistory.length===0) {\r\n    alert('Немає попередніх кроків для відкату.')\r\n    return\r\n  }\r\n  const newHistory=[...stepHistory]\r\n  const lastVisitedNode=newHistory.pop()\r\n  setNodes(prev=>prev.map(n=>n.id===lastVisitedNode?{...n,state:'unvisited'}:n))\r\n  setStepHistory(newHistory)\r\n  setStack(prev=>[...prev,lastVisitedNode])\r\n  const previousNode=newHistory[newHistory.length-1]||null\r\n  setCurrentNode(previousNode)\r\n}\r\n\r\nexport const resetDFSProcess = (setNodes, setStepHistory, setCurrentNode, setTargetNode, setIsRunning, setIsPaused, setStack) => {\r\n  setNodes(prev=>prev.map(n=>({...n,state:'unvisited'})))\r\n  setStepHistory([])\r\n  setCurrentNode(null)\r\n  setTargetNode(null)\r\n  setIsRunning(false)\r\n  setIsPaused(false)\r\n  setStack([])\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}