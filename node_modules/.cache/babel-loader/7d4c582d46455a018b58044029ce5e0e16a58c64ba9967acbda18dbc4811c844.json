{"ast":null,"code":"export const initializeDFS = (nodes, endNodeId) => {\n  const updatedNodes = nodes.map(n => ({\n    ...n,\n    state: 'unvisited'\n  }));\n  return {\n    nodes: updatedNodes,\n    stepHistory: [],\n    currentNode: null,\n    targetNode: endNodeId,\n    stack: []\n  };\n};\nexport const startDFSProcess = (startId, endId, setIsRunning, setIsPaused, setTargetNode, setStack, setNodes) => {\n  setIsRunning(true);\n  setIsPaused(false);\n  setTargetNode(endId);\n  setNodes(p => p.map(n => ({\n    ...n,\n    state: 'unvisited'\n  })));\n  setStack([startId]);\n};\nexport const performDFSStep = async ({\n  nodesRef,\n  edges,\n  stack,\n  setStack,\n  updateNodeState,\n  setStepHistory,\n  delay,\n  targetNode,\n  isPausedRef,\n  setIsRunning\n}) => {\n  let current = null;\n  let currentNode = null;\n  while (true) {\n    if (stack.length === 0) {\n      alert('Цільова вершина не знайдена');\n      setIsRunning(false);\n      return;\n    }\n    if (isPausedRef.current) return;\n    current = stack[stack.length - 1];\n    currentNode = nodesRef.current.find(n => n.id === current);\n    if (!currentNode || currentNode.state !== 'unvisited') {\n      setStack(prev => prev.slice(0, -1));\n      continue;\n    }\n    break;\n  }\n  updateNodeState(current, 'processing');\n  setStepHistory(h => [...h, current]);\n  await new Promise(r => setTimeout(r, delay));\n  if (current === targetNode) {\n    updateNodeState(current, 'target');\n    alert(`Знайдено кінцеву вершину V${targetNode}`);\n    setIsRunning(false);\n    return;\n  }\n  const neighbors = edges.filter(e => e.from === current).map(e => e.to).filter(id => {\n    const nn = nodesRef.current.find(n => n.id === id);\n    return nn && nn.state === 'unvisited';\n  });\n  setStack(s => [...s, ...neighbors.reverse()]);\n  updateNodeState(current, 'visited');\n  await new Promise(r => setTimeout(r, delay));\n};\nexport const pauseDFSProcess = (isRunning, setIsPaused, isPaused) => {\n  if (!isRunning) return;\n  setIsPaused(!isPaused);\n};\nexport const undoDFSProcess = (stepHistory, setStepHistory, setNodes, setStack, setCurrentNode) => {\n  if (stepHistory.length === 0) {\n    alert('Немає попередніх кроків для відкату.');\n    return;\n  }\n  const newHistory = [...stepHistory];\n  const lastVisitedNode = newHistory.pop();\n  setNodes(prev => prev.map(n => n.id === lastVisitedNode ? {\n    ...n,\n    state: 'unvisited'\n  } : n));\n  setStepHistory(newHistory);\n  setStack(prev => [...prev, lastVisitedNode]);\n  const previousNode = newHistory[newHistory.length - 1] || null;\n  setCurrentNode(previousNode);\n};\nexport const resetDFSProcess = (setNodes, setStepHistory, setCurrentNode, setTargetNode, setIsRunning, setIsPaused, setStack) => {\n  setNodes(prev => prev.map(n => ({\n    ...n,\n    state: 'unvisited'\n  })));\n  setStepHistory([]);\n  setCurrentNode(null);\n  setTargetNode(null);\n  setIsRunning(false);\n  setIsPaused(false);\n  setStack([]);\n};","map":{"version":3,"names":["initializeDFS","nodes","endNodeId","updatedNodes","map","n","state","stepHistory","currentNode","targetNode","stack","startDFSProcess","startId","endId","setIsRunning","setIsPaused","setTargetNode","setStack","setNodes","p","performDFSStep","nodesRef","edges","updateNodeState","setStepHistory","delay","isPausedRef","current","length","alert","find","id","prev","slice","h","Promise","r","setTimeout","neighbors","filter","e","from","to","nn","s","reverse","pauseDFSProcess","isRunning","isPaused","undoDFSProcess","setCurrentNode","newHistory","lastVisitedNode","pop","previousNode","resetDFSProcess"],"sources":["D:/kr/src/components/Graph/algorithms/dfs.js"],"sourcesContent":["export const initializeDFS = (nodes, endNodeId) => {\r\n  const updatedNodes = nodes.map(n => ({...n, state:'unvisited'}))\r\n  return {nodes: updatedNodes, stepHistory: [], currentNode: null, targetNode: endNodeId, stack: []}\r\n}\r\n\r\nexport const startDFSProcess = (startId, endId, setIsRunning, setIsPaused, setTargetNode, setStack, setNodes) => {\r\n  setIsRunning(true)\r\n  setIsPaused(false)\r\n  setTargetNode(endId)\r\n  setNodes(p=>p.map(n=>({...n,state:'unvisited'})))\r\n  setStack([startId])\r\n}\r\n\r\nexport const performDFSStep = async ({nodesRef, edges, stack, setStack, updateNodeState, setStepHistory, delay, targetNode, isPausedRef, setIsRunning}) => {\r\n  let current = null\r\n  let currentNode = null\r\n  while (true) {\r\n    if (stack.length === 0) {\r\n      alert('Цільова вершина не знайдена')\r\n      setIsRunning(false)\r\n      return\r\n    }\r\n    if (isPausedRef.current) return\r\n    current = stack[stack.length - 1]\r\n    currentNode = nodesRef.current.find(n=>n.id===current)\r\n    if (!currentNode || currentNode.state !== 'unvisited') {\r\n      setStack(prev=>prev.slice(0,-1))\r\n      continue\r\n    }\r\n    break\r\n  }\r\n  updateNodeState(current, 'processing')\r\n  setStepHistory(h=>[...h,current])\r\n  await new Promise(r=>setTimeout(r,delay))\r\n  if (current === targetNode) {\r\n    updateNodeState(current, 'target')\r\n    alert(`Знайдено кінцеву вершину V${targetNode}`)\r\n    setIsRunning(false)\r\n    return\r\n  }\r\n  const neighbors = edges\r\n    .filter(e=>e.from===current)\r\n    .map(e=>e.to)\r\n    .filter(id=>{\r\n      const nn = nodesRef.current.find(n=>n.id===id)\r\n      return nn && nn.state==='unvisited'\r\n    })\r\n  setStack(s => [...s,...neighbors.reverse()]) \r\n  updateNodeState(current,'visited')\r\n  await new Promise(r=>setTimeout(r,delay))\r\n}\r\n\r\nexport const pauseDFSProcess = (isRunning, setIsPaused, isPaused) => {\r\n  if (!isRunning) return\r\n  setIsPaused(!isPaused)\r\n}\r\n\r\nexport const undoDFSProcess = (stepHistory, setStepHistory, setNodes, setStack, setCurrentNode) => {\r\n  if (stepHistory.length===0) {\r\n    alert('Немає попередніх кроків для відкату.')\r\n    return\r\n  }\r\n  const newHistory = [...stepHistory]\r\n  const lastVisitedNode = newHistory.pop()\r\n  setNodes(prev=>prev.map(n=>n.id===lastVisitedNode?{...n,state:'unvisited'}:n))\r\n  setStepHistory(newHistory)\r\n  setStack(prev=>[...prev,lastVisitedNode])\r\n  const previousNode = newHistory[newHistory.length-1]||null\r\n  setCurrentNode(previousNode)\r\n}\r\n\r\nexport const resetDFSProcess = (setNodes, setStepHistory, setCurrentNode, setTargetNode, setIsRunning, setIsPaused, setStack) => {\r\n  setNodes(prev=>prev.map(n=>({...n,state:'unvisited'})))\r\n  setStepHistory([])\r\n  setCurrentNode(null)\r\n  setTargetNode(null)\r\n  setIsRunning(false)\r\n  setIsPaused(false)\r\n  setStack([])\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}