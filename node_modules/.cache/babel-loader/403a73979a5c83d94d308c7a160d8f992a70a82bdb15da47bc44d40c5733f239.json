{"ast":null,"code":"async function dfsAlgorithm(nodes, edges, startNodeId, setNodesState) {\n  const visited = {};\n  const stack = [];\n  const nodeMap = {};\n  nodes.forEach(node => {\n    nodeMap[node.id] = {\n      ...node,\n      state: 'unvisited'\n    };\n  });\n  stack.push(startNodeId);\n  while (stack.length > 0) {\n    const currentNodeId = stack.pop();\n    const currentNode = nodeMap[currentNodeId];\n    if (!visited[currentNodeId]) {\n      visited[currentNodeId] = true;\n      currentNode.state = 'processing';\n      setNodesState(Object.values(nodeMap));\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Затримка для анімації\n\n      const neighbors = edges.filter(edge => edge.from === currentNodeId).map(edge => edge.to);\n      for (let neighborId of neighbors) {\n        if (!visited[neighborId]) {\n          stack.push(neighborId);\n        }\n      }\n      currentNode.state = 'completed';\n      setNodesState(Object.values(nodeMap));\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Затримка для анімації\n    }\n  }\n}\nexport default dfsAlgorithm;","map":{"version":3,"names":["dfsAlgorithm","nodes","edges","startNodeId","setNodesState","visited","stack","nodeMap","forEach","node","id","state","push","length","currentNodeId","pop","currentNode","Object","values","Promise","resolve","setTimeout","neighbors","filter","edge","from","map","to","neighborId"],"sources":["D:/kr/src/components/Graph/dfsAlgorithm/dfsAlgorithm.js"],"sourcesContent":["async function dfsAlgorithm(nodes, edges, startNodeId, setNodesState) {\r\n  const visited = {};\r\n  const stack = [];\r\n  const nodeMap = {};\r\n  nodes.forEach((node) => {\r\n    nodeMap[node.id] = { ...node, state: 'unvisited' };\r\n  });\r\n\r\n  stack.push(startNodeId);\r\n\r\n  while (stack.length > 0) {\r\n    const currentNodeId = stack.pop();\r\n    const currentNode = nodeMap[currentNodeId];\r\n\r\n    if (!visited[currentNodeId]) {\r\n      visited[currentNodeId] = true;\r\n      currentNode.state = 'processing';\r\n      setNodesState(Object.values(nodeMap));\r\n      await new Promise((resolve) => setTimeout(resolve, 1000)); // Затримка для анімації\r\n\r\n      const neighbors = edges\r\n        .filter((edge) => edge.from === currentNodeId)\r\n        .map((edge) => edge.to);\r\n\r\n      for (let neighborId of neighbors) {\r\n        if (!visited[neighborId]) {\r\n          stack.push(neighborId);\r\n        }\r\n      }\r\n\r\n      currentNode.state = 'completed';\r\n      setNodesState(Object.values(nodeMap));\r\n      await new Promise((resolve) => setTimeout(resolve, 1000)); // Затримка для анімації\r\n    }\r\n  }\r\n}\r\n\r\nexport default dfsAlgorithm;\r\n"],"mappings":"AAAA,eAAeA,YAAYA,CAACC,KAAK,EAAEC,KAAK,EAAEC,WAAW,EAAEC,aAAa,EAAE;EACpE,MAAMC,OAAO,GAAG,CAAC,CAAC;EAClB,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,OAAO,GAAG,CAAC,CAAC;EAClBN,KAAK,CAACO,OAAO,CAAEC,IAAI,IAAK;IACtBF,OAAO,CAACE,IAAI,CAACC,EAAE,CAAC,GAAG;MAAE,GAAGD,IAAI;MAAEE,KAAK,EAAE;IAAY,CAAC;EACpD,CAAC,CAAC;EAEFL,KAAK,CAACM,IAAI,CAACT,WAAW,CAAC;EAEvB,OAAOG,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;IACvB,MAAMC,aAAa,GAAGR,KAAK,CAACS,GAAG,CAAC,CAAC;IACjC,MAAMC,WAAW,GAAGT,OAAO,CAACO,aAAa,CAAC;IAE1C,IAAI,CAACT,OAAO,CAACS,aAAa,CAAC,EAAE;MAC3BT,OAAO,CAACS,aAAa,CAAC,GAAG,IAAI;MAC7BE,WAAW,CAACL,KAAK,GAAG,YAAY;MAChCP,aAAa,CAACa,MAAM,CAACC,MAAM,CAACX,OAAO,CAAC,CAAC;MACrC,MAAM,IAAIY,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;;MAE3D,MAAME,SAAS,GAAGpB,KAAK,CACpBqB,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACC,IAAI,KAAKX,aAAa,CAAC,CAC7CY,GAAG,CAAEF,IAAI,IAAKA,IAAI,CAACG,EAAE,CAAC;MAEzB,KAAK,IAAIC,UAAU,IAAIN,SAAS,EAAE;QAChC,IAAI,CAACjB,OAAO,CAACuB,UAAU,CAAC,EAAE;UACxBtB,KAAK,CAACM,IAAI,CAACgB,UAAU,CAAC;QACxB;MACF;MAEAZ,WAAW,CAACL,KAAK,GAAG,WAAW;MAC/BP,aAAa,CAACa,MAAM,CAACC,MAAM,CAACX,OAAO,CAAC,CAAC;MACrC,MAAM,IAAIY,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC7D;EACF;AACF;AAEA,eAAepB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}