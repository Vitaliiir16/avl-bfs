{"ast":null,"code":"// Визначаємо NIL як порожній об'єкт\nconst NIL = {};\n\n// Клас Node\nclass Node {\n  constructor(value) {\n    this.id = Math.random().toString(36).substr(2, 9); // Унікальний ID\n    this.value = value;\n    this.color = 'red'; // Нові вузли завжди червоні\n    this.left = NIL;\n    this.right = NIL;\n    this.parent = NIL;\n  }\n}\n\n// Ініціалізуємо NIL\nNIL.id = null;\nNIL.value = null;\nNIL.color = 'black';\nNIL.left = null;\nNIL.right = null;\nNIL.parent = null;\n\n// Функція вставки вузла\nexport function insertNode(root, value) {\n  const newNode = new Node(value);\n  let y = NIL;\n  let x = root;\n  while (x !== NIL && x !== null) {\n    y = x;\n    if (newNode.value < x.value) {\n      x = x.left;\n    } else {\n      x = x.right;\n    }\n  }\n  newNode.parent = y;\n  if (y === NIL || y === null) {\n    root = newNode;\n  } else if (newNode.value < y.value) {\n    y.left = newNode;\n  } else {\n    y.right = newNode;\n  }\n  newNode.left = NIL;\n  newNode.right = NIL;\n  newNode.color = 'red';\n  root = fixInsert(root, newNode);\n  return root;\n}\n\n// Функція для балансування після вставки\nfunction fixInsert(root, k) {\n  while (k.parent.color === 'red') {\n    if (k.parent === k.parent.parent.left) {\n      let uncle = k.parent.parent.right;\n      if (uncle.color === 'red') {\n        k.parent.color = 'black';\n        uncle.color = 'black';\n        k.parent.parent.color = 'red';\n        k = k.parent.parent;\n      } else {\n        if (k === k.parent.right) {\n          k = k.parent;\n          root = leftRotate(root, k);\n        }\n        k.parent.color = 'black';\n        k.parent.parent.color = 'red';\n        root = rightRotate(root, k.parent.parent);\n      }\n    } else {\n      let uncle = k.parent.parent.left;\n      if (uncle.color === 'red') {\n        k.parent.color = 'black';\n        uncle.color = 'black';\n        k.parent.parent.color = 'red';\n        k = k.parent.parent;\n      } else {\n        if (k === k.parent.left) {\n          k = k.parent;\n          root = rightRotate(root, k);\n        }\n        k.parent.color = 'black';\n        k.parent.parent.color = 'red';\n        root = leftRotate(root, k.parent.parent);\n      }\n    }\n  }\n  root.color = 'black';\n  return root;\n}\n\n// Функція видалення вузла\nexport function deleteNode(root, value) {\n  let z = searchNode(root, value);\n  if (z === NIL || z === null) return root;\n  let y = z;\n  let yOriginalColor = y.color;\n  let x;\n  if (z.left === NIL) {\n    x = z.right;\n    root = transplant(root, z, z.right);\n  } else if (z.right === NIL) {\n    x = z.left;\n    root = transplant(root, z, z.left);\n  } else {\n    y = treeMinimum(z.right);\n    yOriginalColor = y.color;\n    x = y.right;\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      root = transplant(root, y, y.right);\n      y.right = z.right;\n      y.right.parent = y;\n    }\n    root = transplant(root, z, y);\n    y.left = z.left;\n    y.left.parent = y;\n    y.color = z.color;\n  }\n  if (yOriginalColor === 'black') {\n    root = fixDelete(root, x);\n  }\n  return root;\n}\n\n// Функція для заміни одного піддерева іншим\nfunction transplant(root, u, v) {\n  if (u.parent === NIL || u.parent === null) {\n    root = v;\n  } else if (u === u.parent.left) {\n    u.parent.left = v;\n  } else {\n    u.parent.right = v;\n  }\n  v.parent = u.parent;\n  return root;\n}\n\n// Функція для балансування після видалення\nfunction fixDelete(root, x) {\n  while (x !== root && x.color === 'black') {\n    if (x === x.parent.left) {\n      let w = x.parent.right;\n      if (w.color === 'red') {\n        w.color = 'black';\n        x.parent.color = 'red';\n        root = leftRotate(root, x.parent);\n        w = x.parent.right;\n      }\n      if (w.left.color === 'black' && w.right.color === 'black') {\n        w.color = 'red';\n        x = x.parent;\n      } else {\n        if (w.right.color === 'black') {\n          w.left.color = 'black';\n          w.color = 'red';\n          root = rightRotate(root, w);\n          w = x.parent.right;\n        }\n        w.color = x.parent.color;\n        x.parent.color = 'black';\n        w.right.color = 'black';\n        root = leftRotate(root, x.parent);\n        x = root;\n      }\n    } else {\n      let w = x.parent.left;\n      if (w.color === 'red') {\n        w.color = 'black';\n        x.parent.color = 'red';\n        root = rightRotate(root, x.parent);\n        w = x.parent.left;\n      }\n      if (w.left.color === 'black' && w.right.color === 'black') {\n        w.color = 'red';\n        x = x.parent;\n      } else {\n        if (w.left.color === 'black') {\n          w.right.color = 'black';\n          w.color = 'red';\n          root = leftRotate(root, w);\n          w = x.parent.left;\n        }\n        w.color = x.parent.color;\n        x.parent.color = 'black';\n        w.left.color = 'black';\n        root = rightRotate(root, x.parent);\n        x = root;\n      }\n    }\n  }\n  x.color = 'black';\n  return root;\n}\n\n// Функція для пошуку мінімального вузла\nfunction treeMinimum(x) {\n  while (x.left !== NIL) {\n    x = x.left;\n  }\n  return x;\n}\n\n// Функція пошуку вузла\nexport function searchNode(root, value) {\n  let current = root;\n  while (current !== NIL && current !== null) {\n    if (value === current.value) {\n      return current;\n    } else if (value < current.value) {\n      current = current.left;\n    } else {\n      current = current.right;\n    }\n  }\n  return null;\n}\n\n// Функція лівого повороту\nfunction leftRotate(root, x) {\n  let y = x.right;\n  x.right = y.left;\n  if (y.left !== NIL) {\n    y.left.parent = x;\n  }\n  y.parent = x.parent;\n  if (x.parent === NIL || x.parent === null) {\n    root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n  y.left = x;\n  x.parent = y;\n  return root;\n}\n\n// Функція правого повороту\nfunction rightRotate(root, y) {\n  let x = y.left;\n  y.left = x.right;\n  if (x.right !== NIL) {\n    x.right.parent = y;\n  }\n  x.parent = y.parent;\n  if (y.parent === NIL || y.parent === null) {\n    root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n  x.right = y;\n  y.parent = x;\n  return root;\n}\n\n// Експортуємо необхідні функції та NIL\nexport { NIL };","map":{"version":3,"names":["NIL","Node","constructor","value","id","Math","random","toString","substr","color","left","right","parent","insertNode","root","newNode","y","x","fixInsert","k","uncle","leftRotate","rightRotate","deleteNode","z","searchNode","yOriginalColor","transplant","treeMinimum","fixDelete","u","v","w","current"],"sources":["D:/kr/src/components/RedBlackTree/rbtOperations.js"],"sourcesContent":["// Визначаємо NIL як порожній об'єкт\r\nconst NIL = {};\r\n\r\n// Клас Node\r\nclass Node {\r\n  constructor(value) {\r\n    this.id = Math.random().toString(36).substr(2, 9); // Унікальний ID\r\n    this.value = value;\r\n    this.color = 'red'; // Нові вузли завжди червоні\r\n    this.left = NIL;\r\n    this.right = NIL;\r\n    this.parent = NIL;\r\n  }\r\n}\r\n\r\n// Ініціалізуємо NIL\r\nNIL.id = null;\r\nNIL.value = null;\r\nNIL.color = 'black';\r\nNIL.left = null;\r\nNIL.right = null;\r\nNIL.parent = null;\r\n\r\n// Функція вставки вузла\r\nexport function insertNode(root, value) {\r\n  const newNode = new Node(value);\r\n\r\n  let y = NIL;\r\n  let x = root;\r\n\r\n  while (x !== NIL && x !== null) {\r\n    y = x;\r\n    if (newNode.value < x.value) {\r\n      x = x.left;\r\n    } else {\r\n      x = x.right;\r\n    }\r\n  }\r\n\r\n  newNode.parent = y;\r\n\r\n  if (y === NIL || y === null) {\r\n    root = newNode;\r\n  } else if (newNode.value < y.value) {\r\n    y.left = newNode;\r\n  } else {\r\n    y.right = newNode;\r\n  }\r\n\r\n  newNode.left = NIL;\r\n  newNode.right = NIL;\r\n  newNode.color = 'red';\r\n\r\n  root = fixInsert(root, newNode);\r\n  return root;\r\n}\r\n\r\n// Функція для балансування після вставки\r\nfunction fixInsert(root, k) {\r\n  while (k.parent.color === 'red') {\r\n    if (k.parent === k.parent.parent.left) {\r\n      let uncle = k.parent.parent.right;\r\n      if (uncle.color === 'red') {\r\n        k.parent.color = 'black';\r\n        uncle.color = 'black';\r\n        k.parent.parent.color = 'red';\r\n        k = k.parent.parent;\r\n      } else {\r\n        if (k === k.parent.right) {\r\n          k = k.parent;\r\n          root = leftRotate(root, k);\r\n        }\r\n        k.parent.color = 'black';\r\n        k.parent.parent.color = 'red';\r\n        root = rightRotate(root, k.parent.parent);\r\n      }\r\n    } else {\r\n      let uncle = k.parent.parent.left;\r\n      if (uncle.color === 'red') {\r\n        k.parent.color = 'black';\r\n        uncle.color = 'black';\r\n        k.parent.parent.color = 'red';\r\n        k = k.parent.parent;\r\n      } else {\r\n        if (k === k.parent.left) {\r\n          k = k.parent;\r\n          root = rightRotate(root, k);\r\n        }\r\n        k.parent.color = 'black';\r\n        k.parent.parent.color = 'red';\r\n        root = leftRotate(root, k.parent.parent);\r\n      }\r\n    }\r\n  }\r\n  root.color = 'black';\r\n  return root;\r\n}\r\n\r\n// Функція видалення вузла\r\nexport function deleteNode(root, value) {\r\n  let z = searchNode(root, value);\r\n  if (z === NIL || z === null) return root;\r\n\r\n  let y = z;\r\n  let yOriginalColor = y.color;\r\n  let x;\r\n\r\n  if (z.left === NIL) {\r\n    x = z.right;\r\n    root = transplant(root, z, z.right);\r\n  } else if (z.right === NIL) {\r\n    x = z.left;\r\n    root = transplant(root, z, z.left);\r\n  } else {\r\n    y = treeMinimum(z.right);\r\n    yOriginalColor = y.color;\r\n    x = y.right;\r\n    if (y.parent === z) {\r\n      x.parent = y;\r\n    } else {\r\n      root = transplant(root, y, y.right);\r\n      y.right = z.right;\r\n      y.right.parent = y;\r\n    }\r\n    root = transplant(root, z, y);\r\n    y.left = z.left;\r\n    y.left.parent = y;\r\n    y.color = z.color;\r\n  }\r\n\r\n  if (yOriginalColor === 'black') {\r\n    root = fixDelete(root, x);\r\n  }\r\n\r\n  return root;\r\n}\r\n\r\n// Функція для заміни одного піддерева іншим\r\nfunction transplant(root, u, v) {\r\n  if (u.parent === NIL || u.parent === null) {\r\n    root = v;\r\n  } else if (u === u.parent.left) {\r\n    u.parent.left = v;\r\n  } else {\r\n    u.parent.right = v;\r\n  }\r\n  v.parent = u.parent;\r\n  return root;\r\n}\r\n\r\n// Функція для балансування після видалення\r\nfunction fixDelete(root, x) {\r\n  while (x !== root && x.color === 'black') {\r\n    if (x === x.parent.left) {\r\n      let w = x.parent.right;\r\n      if (w.color === 'red') {\r\n        w.color = 'black';\r\n        x.parent.color = 'red';\r\n        root = leftRotate(root, x.parent);\r\n        w = x.parent.right;\r\n      }\r\n      if (w.left.color === 'black' && w.right.color === 'black') {\r\n        w.color = 'red';\r\n        x = x.parent;\r\n      } else {\r\n        if (w.right.color === 'black') {\r\n          w.left.color = 'black';\r\n          w.color = 'red';\r\n          root = rightRotate(root, w);\r\n          w = x.parent.right;\r\n        }\r\n        w.color = x.parent.color;\r\n        x.parent.color = 'black';\r\n        w.right.color = 'black';\r\n        root = leftRotate(root, x.parent);\r\n        x = root;\r\n      }\r\n    } else {\r\n      let w = x.parent.left;\r\n      if (w.color === 'red') {\r\n        w.color = 'black';\r\n        x.parent.color = 'red';\r\n        root = rightRotate(root, x.parent);\r\n        w = x.parent.left;\r\n      }\r\n      if (w.left.color === 'black' && w.right.color === 'black') {\r\n        w.color = 'red';\r\n        x = x.parent;\r\n      } else {\r\n        if (w.left.color === 'black') {\r\n          w.right.color = 'black';\r\n          w.color = 'red';\r\n          root = leftRotate(root, w);\r\n          w = x.parent.left;\r\n        }\r\n        w.color = x.parent.color;\r\n        x.parent.color = 'black';\r\n        w.left.color = 'black';\r\n        root = rightRotate(root, x.parent);\r\n        x = root;\r\n      }\r\n    }\r\n  }\r\n  x.color = 'black';\r\n  return root;\r\n}\r\n\r\n// Функція для пошуку мінімального вузла\r\nfunction treeMinimum(x) {\r\n  while (x.left !== NIL) {\r\n    x = x.left;\r\n  }\r\n  return x;\r\n}\r\n\r\n// Функція пошуку вузла\r\nexport function searchNode(root, value) {\r\n  let current = root;\r\n  while (current !== NIL && current !== null) {\r\n    if (value === current.value) {\r\n      return current;\r\n    } else if (value < current.value) {\r\n      current = current.left;\r\n    } else {\r\n      current = current.right;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n// Функція лівого повороту\r\nfunction leftRotate(root, x) {\r\n  let y = x.right;\r\n  x.right = y.left;\r\n  if (y.left !== NIL) {\r\n    y.left.parent = x;\r\n  }\r\n  y.parent = x.parent;\r\n  if (x.parent === NIL || x.parent === null) {\r\n    root = y;\r\n  } else if (x === x.parent.left) {\r\n    x.parent.left = y;\r\n  } else {\r\n    x.parent.right = y;\r\n  }\r\n  y.left = x;\r\n  x.parent = y;\r\n  return root;\r\n}\r\n\r\n// Функція правого повороту\r\nfunction rightRotate(root, y) {\r\n  let x = y.left;\r\n  y.left = x.right;\r\n  if (x.right !== NIL) {\r\n    x.right.parent = y;\r\n  }\r\n  x.parent = y.parent;\r\n  if (y.parent === NIL || y.parent === null) {\r\n    root = x;\r\n  } else if (y === y.parent.right) {\r\n    y.parent.right = x;\r\n  } else {\r\n    y.parent.left = x;\r\n  }\r\n  x.right = y;\r\n  y.parent = x;\r\n  return root;\r\n}\r\n\r\n// Експортуємо необхідні функції та NIL\r\nexport { NIL };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}